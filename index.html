<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cherry Blossom Tree - Clicker</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="game-container clicker-only">
        <h1>ðŸŒ¸ Cherry Blossom Tree ðŸŒ¸</h1>
        <p class="nav-link"><a href="stats.html">Scoreboard & Upgrades â†’</a></p>

        <!-- Click Area -->
        <div class="panel click-area">
            <h2>Click the tree to add blossoms</h2>
            <p class="blossom-count">Blossoms on tree: <span id="crystalCount">0</span></p>
            <div class="tree-stage" id="treeStage">
                <img class="tree-bare" id="treeBare" src="images/empty-tree.png" alt="">
                <div class="tree-blossoms" id="treeBlossoms"></div>
                <button class="tree-hit-area" id="clickBtn" aria-label="Click tree to add cherry blossoms"></button>
            </div>
            <p class="click-text">Each click adds <span class="click-value" id="clickValueDisplay">+1</span> blossom<span id="pluralS">s</span></p>
            <div class="auto-indicator" id="autoIndicator">
                <p>Blossoms drifting in: <span class="auto-value" id="autoValue">0</span>/sec</p>
            </div>
            <button type="button" class="reset-btn" id="resetBtn">Reset tree</button>
        </div>
    </div>

    <script>
        const gameState = {
            crystals: 0,
            totalCrystals: 0,
            clickValue: 1,
            totalClicks: 0,
            autoClickValue: 0,
            upgrades: {},
            achievements: new Set()
        };

        const clickBtn = document.getElementById('clickBtn');
        const crystalCountEl = document.getElementById('crystalCount');
        const clickValueDisplayEl = document.getElementById('clickValueDisplay');
        const autoIndicatorEl = document.getElementById('autoIndicator');
        const autoValueEl = document.getElementById('autoValue');
        const pluralEl = document.getElementById('pluralS');
        const treeBlossomsEl = document.getElementById('treeBlossoms');

        const BLOSSOM_MAX = 400;
        const BLOSSOM_IMG = 'images/cherry-blossom.png';

        function addBlossomAt(percentX, percentY) {
            const img = document.createElement('img');
            img.src = BLOSSOM_IMG;
            img.alt = '';
            img.className = 'blossom-petal';
            img.style.left = percentX + '%';
            img.style.top = percentY + '%';
            treeBlossomsEl.appendChild(img);
        }

        function trimBlossomsToMax() {
            while (treeBlossomsEl.children.length > BLOSSOM_MAX) {
                treeBlossomsEl.removeChild(treeBlossomsEl.firstChild);
            }
        }

        function resetTree() {
            treeBlossomsEl.innerHTML = '';
            gameState.crystals = 0;
            gameState.totalCrystals = 0;
            gameState.clickValue = 1;
            gameState.totalClicks = 0;
            gameState.autoClickValue = 0;
            gameState.upgrades = {};
            gameState.achievements = new Set();
            updateUI();
            saveGame();
        }

        // Tree boundary: ellipse matching canopy/trunk (percent). Only add blossoms inside.
        function isInsideTreeBoundary(percentX, percentY) {
            const cx = 50, cy = 50, rx = 42, ry = 48;
            const dx = (percentX - cx) / rx;
            const dy = (percentY - cy) / ry;
            return dx * dx + dy * dy <= 1 && percentY >= 4 && percentY <= 97;
        }

        function randomTreePosition() {
            const cx = 50, cy = 50, rx = 42, ry = 48;
            const angle = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random());
            return {
                x: cx + rx * r * Math.cos(angle),
                y: cy + ry * r * Math.sin(angle)
            };
        }

        function seedBlossomsForLoad() {
            const n = Math.min(Math.floor(gameState.crystals), BLOSSOM_MAX);
            for (let i = 0; i < n; i++) {
                const p = randomTreePosition();
                addBlossomAt(p.x, p.y);
            }
        }

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return Math.floor(num).toString();
        }

        function createFloatingNumber(x, y, value) {
            const el = document.createElement('div');
            el.className = 'float-number';
            el.textContent = '+' + formatNumber(value) + ' ðŸŒ¸';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updateUI() {
            crystalCountEl.textContent = formatNumber(gameState.crystals);
            clickValueDisplayEl.textContent = '+' + formatNumber(gameState.clickValue);
            if (pluralEl) pluralEl.textContent = gameState.clickValue === 1 ? '' : 's';
            if (gameState.autoClickValue > 0) {
                autoIndicatorEl.classList.add('active');
                autoValueEl.textContent = formatNumber(gameState.autoClickValue);
            }
        }

        clickBtn.addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const percentX = ((e.clientX - rect.left) / rect.width) * 100;
            const percentY = ((e.clientY - rect.top) / rect.height) * 100;
            if (!isInsideTreeBoundary(percentX, percentY)) return;
            for (let i = 0; i < gameState.clickValue; i++) {
                const offset = (i - gameState.clickValue / 2) * 3;
                const px = percentX + (Math.random() - 0.5) * 8 + offset;
                const py = percentY + (Math.random() - 0.5) * 8;
                if (isInsideTreeBoundary(px, py)) {
                    addBlossomAt(px, py);
                } else {
                    addBlossomAt(percentX, percentY);
                }
            }
            trimBlossomsToMax();
            gameState.crystals += gameState.clickValue;
            gameState.totalCrystals += gameState.clickValue;
            gameState.totalClicks++;
            createFloatingNumber(e.clientX, e.clientY, gameState.clickValue);
            updateUI();
        });

        setInterval(() => {
            if (gameState.autoClickValue > 0) {
                for (let i = 0; i < gameState.autoClickValue; i++) {
                    const p = randomTreePosition();
                    addBlossomAt(p.x, p.y);
                }
                trimBlossomsToMax();
                gameState.crystals += gameState.autoClickValue;
                gameState.totalCrystals += gameState.autoClickValue;
                updateUI();
            }
        }, 1000);

        function saveGame() {
            const saveData = {
                crystals: gameState.crystals,
                totalCrystals: gameState.totalCrystals,
                clickValue: gameState.clickValue,
                totalClicks: gameState.totalClicks,
                autoClickValue: gameState.autoClickValue,
                upgrades: gameState.upgrades,
                achievements: Array.from(gameState.achievements)
            };
            localStorage.setItem('crystalClickerSave', JSON.stringify(saveData));
        }

        function loadGame() {
            const saved = localStorage.getItem('crystalClickerSave');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.crystals = data.crystals || 0;
                gameState.totalCrystals = data.totalCrystals || 0;
                gameState.clickValue = data.clickValue || 1;
                gameState.totalClicks = data.totalClicks || 0;
                gameState.autoClickValue = data.autoClickValue || 0;
                gameState.upgrades = data.upgrades || {};
                gameState.achievements = new Set(data.achievements || []);
            }
        }

        loadGame();
        seedBlossomsForLoad();
        updateUI();

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (confirm('Reset the tree and all progress? Blossoms and upgrades will be cleared.')) {
                resetTree();
            }
        });

        setInterval(saveGame, 30000);
        window.addEventListener('beforeunload', saveGame);
    </script>
</body>
</html>
